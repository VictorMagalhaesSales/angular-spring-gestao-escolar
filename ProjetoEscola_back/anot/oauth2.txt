000000000000000000
000000 OAUTH 2 000000
000000000000000000

======------ RESOURCE SERVER -----======
1 - Criaremos o 'ResourceServerConfig' que tem 3 anota珲es (@Configuration, @EnableResourceServer, @EnableWebSecurity ) e extende da classe 'ResourceServerConfigurerAdapter';
2 - O mtodo configure(auth) define os usurios(login e senha);
3 - O mtodo configure(http) define a segurana;
4 - O mtodo configure( resources) define o estado da API;



============----------- AUTHENTICATION SERVER ----------============
1 - Criaremos o 'AuthenticationServerConfig' para controlar o servidor de autentica玢o. Anota珲es: @Configuration/@EnableAuthorizationServer. Extende do AuthorizationServerConfigurerAdapter;
2 - O mtodo configure(clients) serve para defiinir o login do cliente;
3 - O mtodo configure(endpoints) para definirmos onde ser armazenado o login do usurio;
4 - O mtodo @Bean TokenStore tokenStore() para informar como armazenaremos o token;

// *** Agora, precisamos pegar um TOKEN na url: localhost:8080/oauth/token, passando os logins do cliente e depois do usurio como POST. Receberemos um token atravs do body que ter um tempo de expira玢o que usaremos nas requisi珲es para ter a autoriza玢o *** //



============----------- JASON WEB TOKEN ----------============
1 - Conversor de TOKEN: no AuthorizationServerEndpointsConfigurer, botaremos um .acessTokenConverter(acessTokenConverter());
2 - O mtodo @Bean acessTokenConverter() converte o JWT TOKEN;
3 - Modificaremos o tokenStore(), botando o retorno para JWTTokenStore(acessTokenConverter());

// *** A partir de agora, o nosso token estar no formato JWT. Ento, ele ser maior e mais seguro *** //



============----------- REFRESH TOKEN ----------============
1 - Adicionamos, no authorizedGrantTypes, o "refresh_token";
2 - Setaremos um tempo de vida para o refresh token no mtodo configure(http) com: '.refreshTokenValidSeconds(segundos)';
3 - Em configure(endpoints), setamos '.reuseRefreshToken(false)';

// *** O Refresh Token sempre retorna um novo Acess Token, quando este espira( recomendado ter o tempo de vida muito pequeno) *** //



============----------- REFRESH TOKEN NO COOKIE ----------============
1 - Criaremos uma classe que deve receber a anota玢o @ControllerAdvice, o que lhe permite interceptar as requisi珲es, token e tirar o refresh token do body e coloca-lo no cookie;
2 - A classe implementa 'ResponseBodyAdvice<OAuth2AccessToken>'. O que est entre < >  o tipo de dado que, quando for retornado no body, ser interceptado;
3 - Ao implementar, teremos 2 mtodos. O supports(), quando retornar 'true', automaticamente executa o mtodo beforeBodyWrite().
4 - Botaremos o retorno do supports() como: return returnType.getMethod().getName().equals("postAccessToken");
5 - No 'beforeBodyWrite()' vamos recuperar o corpo da requisi玢o, tirar o refresh e bota-lo no cookie;

// *** Agora estamos tirando o refresh token da requisi玢o, botando no corpo e depois no cookie *** //



============----------- REFRESH TOKEN DO COOKIE PARA REQUISI敲O ----------============
1 - Criar classe com @Component, @Order(Odered.HIGHEST_PRECEDENCE), que implementa FIlter;
2 - No mtodo doFilter(), verificamos se a requisi玢o est em 'lh:8080/au/tk',  se tem o parmetro 'grant_type' com o 'refresh_token' e se tem algum cookie(no caso, o refres). Se for verdadeiro, pegaremos o cookie e adicionamos dentro do mapa de parmetros dentro da requisi玢o;



============----------- AUTENTICA敲O PELO BANCO DE DADOS ----------============
1 - No mtodo configure(auth), do ResourceServerConfig, substituiremos os mtodos por '.userDetailsService()';
2 - Inje玢o de dependncia do UserDetailsService;
3 - Criaremos a classe AppUserDetailsService que implementa UserDatilsService e adicionamos o mtodo loadUserByUsername, para fazer a busca do usurio no banco de dados; ( @Service )
4 - Criaremos o usurio que recebe a busca do usurio pelo login, atravez do mtodo criado no Repository, FindBy...();
5 - Testaremos se esse usurio est vazio, se sim retornaremos um new UsernameNotFoundException("Usurio/senha incorreto(s)");
6 - Se der certo, retorno um new User(username, senha, permissoes);
7 - Adicionaremos o mtodo .passwordEncoder(passwordEncoder()) no configure(auth);
8 - Criaremos um mtodo @Bean passwordEncoder() que retorne new BCryptPasswordEncoder();




=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= OBS =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  Para resolver o erro com o AuthenticationManager:
      Devemos manter uma classe de segurana que extende de WebSecurityConfigurerAdapter, com o mtodo 'AuthenticationManager authenticationManagerBean()', com a anota玢o @Bean

 Para resolver o erro 'There is no PasswordEncoder mapped for the id "null" '
     Devemos adicionar um {noop} na String de senha do usurio e do cliente: .secret("{noop}angular") e .password("{noop}admin")
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=